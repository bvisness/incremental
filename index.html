<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Incremental Rendering Tests</title>

    <link rel="stylesheet" href="/normalize.css">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system,BlinkMacSystemFont,segoe ui,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;
        }

        .main {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
        }

        .description {
            padding: 0.8rem;
        }

        .cases {
            display: flex;
            flex-grow: 1;
            overflow-x: auto;
            border-top: 1px solid #ccc;
        }

        .cases > div {
            width: 22rem;
            flex-shrink: 0;
            padding: 0 0.8rem 0.8rem;
            overflow-y: auto;
        }

        .cases > div:not(:last-child) {
            border-right: 1px solid #ccc;
        }

        input {
            width: 100%;
        }

        h4 {
            margin: 0.8em 0 0.4em;
        }

        p {
            margin: 0.4em 0;
        }

        .highlight {
            background-color: yellow;
            border: 1px solid #999;
            border-radius: 3px;
        }
    </style>

    <script src="react.development.js"></script>
    <script src="react-dom.development.js"></script>
    <script>
        const e = React.createElement;

        const MAX_INCREMENTAL = 20;
    </script>
</head>

<body>
    <div class="main">
        <div class="description">
            An experiment to see if anything I do with React can match the performance of the search on the truly massive <a href="https://hero.handmade.network/episode/code">Handmade Hero episode guide</a>. View the source code for details on each algorithm.
        </div>
        <div class="cases">
            <div>
                <h2>Vanilla (Naive)</h2>
                <div id="vn-container">
                    <input id="vn-query">
                    <div id="vn-results"></div>
                </div>
            </div>
            <div>
                <h2>Vanilla (Incremental)</h2>
                <div id="vi-container">
                    <input id="vi-query">
                    <div id="vi-results"></div>
                </div>
            </div>
            <div>
                <h2>React (Naive)</h2>
                <div id="rn-container"></div>
            </div>
            <div>
                <h2>React (Naive, Faster Diffing)</h2>
                <div id="rnf-container"></div>
            </div>
            <div>
                <h2>React (Incremental)</h2>
                <div id="ri-container"></div>
            </div>
            <div>
                <h2>React (Incremental, Faster Diffing)</h2>
                <div id="rif-container"></div>
            </div>
            <div>
                <h2>React (Naive, Incremental Portals)</h2>
                <div id="rip-container"></div>
            </div>
        </div>
    </div>

    <script src="project.js"></script>

    <script>
        var project = getProject();

        var renderHandle;

        /*
        Searches the episode information and returns all the results.
        Used by all test cases.
        
        Adapted from the original: https://handmade.network/static/annotations/cinera_search.js
        */
        function runSearch(queryStr) {
            var numEpisodes = 0;
            var numMarkers = 0;
            var totalSeconds = 0;

            // NOTE(matt):  Function defined within runSearch() so that we can modify numEpisodes, numMarkers and totalSeconds
            function runSearchInterior(resultsToRender, query, episode)
            {
                var matches = [];
                for (var k = 0; k < episode.markers.length; ++k) {
                    query.lastIndex = 0;
                    var result = query.exec(episode.markers[k].text);
                    if (result && result[0].length > 0) {
                        numMarkers++;
                        matches.push(episode.markers[k]);
                        if (k < episode.markers.length-1) {
                            totalSeconds += episode.markers[k+1].totalTime - episode.markers[k].totalTime;
                        }
                    }
                }
                if (matches.length > 0) {
                    numEpisodes++;
                    resultsToRender.push({
                        query: query,
                        episode: episode,
                        matches: matches
                    });
                }
            }

            var results = [];
            if (queryStr && queryStr.length > 0) {
                var query = new RegExp(queryStr.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'), 'gi');

                if(project.parsed && !project.filteredOut && project.episodes.length > 0) {
                    for(var j = 0; j < project.episodes.length; ++j) {
                        var episode = project.episodes[j];
                        runSearchInterior(results, query, episode);
                    }
                }
            }

            var totalTime = Math.floor(totalSeconds/60/60) + "h " + Math.floor(totalSeconds/60)%60 + "m " + totalSeconds%60 + "s ";

            return [results, "Found: " + numEpisodes + " episodes, " + numMarkers + " markers, " + totalTime + "total."];
        }

        function renderResultVanilla(r) {
            const resultEl = document.createElement('div');

            const header = document.createElement('h4');
            header.innerText = r.episode.title;
            resultEl.appendChild(header);

            for (const m of r.matches) {
                const p = document.createElement('p');

                p.appendChild(document.createTextNode(`${m.prettyTime} `));

                let startIndex = 0;
                for (const highlightMatch of m.text.matchAll(r.query)) {
                    const text = m.text.slice(startIndex, highlightMatch.index);
                    p.appendChild(document.createTextNode(text));

                    const span = document.createElement('span');
                    span.classList.add('highlight');
                    span.innerText = highlightMatch[0];
                    p.appendChild(span);

                    startIndex = highlightMatch.index + highlightMatch[0].length;
                }

                const remainingText = m.text.slice(startIndex);
                p.appendChild(document.createTextNode(remainingText));

                resultEl.appendChild(p);
            }

            return resultEl;
        }

        /*
        Renders results as straightforwardly as possible.
        */
        function renderNaive(results) {
            document.querySelector('#vn-results').innerHTML = '';

            for (const r of results) {
                document.querySelector('#vn-results').appendChild(renderResultVanilla(r));
            }
        }

        /*
        Renders results incrementally, processing and adding a chunk of
        items to the DOM at a time.
        */
        function renderIncremental(results, i = 0) {
            var numItems = 0;

            if (i === 0) {
                document.querySelector('#vi-results').innerHTML = '';
                clearTimeout(renderHandle);
            }

            if (i < results.length) {
                rendering = true;

                while (numItems < MAX_INCREMENTAL && i < results.length) {
                    document.querySelector('#vi-results').appendChild(renderResultVanilla(results[i]));

                    numItems++;
                    i++;
                }

                renderHandle = setTimeout(() => renderIncremental(results, i), 0);
            } else {
                rendering = false;
            }
        }

        document.querySelector('#vn-query').addEventListener('input', e => {
            const [results, summary] = runSearch(e.target.value);
            renderNaive(results);
        });
        document.querySelector('#vi-query').addEventListener('input', e => {
            const [results, summary] = runSearch(e.target.value);
            renderIncremental(results);
        });

        /*
        A React component that renders a result and all its matches.
        */
        function SearchResult({ result }) {
            return e(React.Fragment, {},
                e('h4', {}, result.episode.title),
                result.matches.map(m => (
                    e(SearchResultMatch, {key: m.prettyTime, result: result, match: m})
                )),
            );
        }

        /*
        A React component that renders a specific matching annotation,
        with highlights.
        */
        function SearchResultMatch({ result, match }) {
            const children = [];

            children.push(`${match.prettyTime} `);

            let startIndex = 0;
            for (const highlightMatch of match.text.matchAll(result.query)) {
                children.push(match.text.slice(startIndex, highlightMatch.index));
                children.push(e('span', {className: 'highlight'}, highlightMatch[0]));

                startIndex = highlightMatch.index + highlightMatch[0].length;
            }

            children.push(match.text.slice(startIndex));

            return e('p', {}, ...children);
        }

        /*
        Renders items using React as straightforwardly as possible.
        */
        function ReactNaive() {
            const [query, setQuery] = React.useState('');

            function handleChange(e) {
                setQuery(e.target.value);
            }
            
            const [results, summary] = runSearch(query);

            return e(React.Fragment, {},
                e('input', {value: query, onChange: handleChange}),
                e('div', {}, results.map(r => (
                    e('div', {key: r.episode.day},
                        e(SearchResult, {result: r}),
                    )
                ))),
            );
        }
        ReactDOM.render(e(ReactNaive), document.querySelector('#rn-container'));

        /*
        Renders all items at once, but does a trick to reduce diffing times.
        */
        function ReactNaiveFastDiffing() {
            /*
            According to https://reactjs.org/docs/reconciliation.html, React
            assumes that switching the type of an element (e.g. from div to
            span) will always result in different trees, thus providing a
            fast path out for the diffing algorithm. So by swapping element
            types on every render, we should effectively skip all diffing, at
            the cost of not preserving component state.
            */

            const [query, setQuery] = React.useState('');
            const [typeToggle, setTypeToggle] = React.useState(false);

            function handleChange(e) {
                setQuery(e.target.value);
                setTypeToggle(!typeToggle);
            }

            const [results, summary] = runSearch(query);

            const ContainerA = props => e('div', {}, props.children);
            const ContainerB = props => e('div', {}, props.children);

            return e(React.Fragment, {},
                e('input', {value: query, onChange: handleChange}),
                e(typeToggle ? ContainerA : ContainerB, {}, results.map(r => (
                    e('div', {key: r.episode.day},
                        e(SearchResult, { result: r }),
                    )
                ))),
            );
        }
        ReactDOM.render(e(ReactNaiveFastDiffing), document.querySelector('#rnf-container'));

        /*
        Renders items incrementally using React.
        */
        function ReactIncremental() {
            const [query, setQuery] = React.useState('');
            const [results, setResults] = React.useState([]);
            const [maxIndex, setMaxIndex] = React.useState(0);

            const renderHandle = React.useRef(null);

            function handleChange(e) {
                setQuery(e.target.value);
                setMaxIndex(MAX_INCREMENTAL);
            }

            React.useEffect(() => {
                clearTimeout(renderHandle.current);

                const [newResults, newSummary] = runSearch(query);
                setResults(newResults);
            }, [query]);

            React.useEffect(() => {
                if (maxIndex < results.length) {
                    const handle = setTimeout(() => setMaxIndex(maxIndex + MAX_INCREMENTAL), 0);
                    renderHandle.current = handle;
                }
            });

            const resultSlice = results.slice(0, Math.min(maxIndex, results.length));

            return e(React.Fragment, {},
                e('input', {value: query, onChange: handleChange}),
                e('div', {}, resultSlice.map(r => (
                    e('div', {key: r.episode.day},
                        e(SearchResult, {result: r}),
                    )
                ))),
            );
        }
        ReactDOM.render(e(ReactIncremental), document.querySelector('#ri-container'));

        /*
        Renders items incrementally using React, with the trick from
        before to reduce diffing times.
        */
        function ReactIncrementalFastDiffing() {
            const [query, setQuery] = React.useState('');
            const [typeToggle, setTypeToggle] = React.useState(false);
            const [results, setResults] = React.useState([]);
            const [maxIndex, setMaxIndex] = React.useState(0);

            const renderHandle = React.useRef(null);

            function handleChange(e) {
                setQuery(e.target.value);
                setMaxIndex(MAX_INCREMENTAL);
                setTypeToggle(!typeToggle);
            }

            React.useEffect(() => {
                clearTimeout(renderHandle.current);

                const [newResults, newSummary] = runSearch(query);
                setResults(newResults);
            }, [query]);

            React.useEffect(() => {
                if (maxIndex < results.length) {
                    const handle = setTimeout(() => setMaxIndex(maxIndex + MAX_INCREMENTAL), 0);
                    renderHandle.current = handle;
                }
            });

            const resultSlice = results.slice(0, Math.min(maxIndex, results.length));

            const ContainerA = props => e('div', {}, props.children);
            const ContainerB = props => e('div', {}, props.children);

            return e(React.Fragment, {},
                e('input', {value: query, onChange: handleChange}),
                e(typeToggle ? ContainerA : ContainerB, {}, resultSlice.map(r => (
                    e('div', {key: r.episode.day},
                        e(SearchResult, {result: r}),
                    )
                ))),
            );
        }
        ReactDOM.render(e(ReactIncrementalFastDiffing), document.querySelector('#rif-container'));

        /*
        Attempts to reduce the cost of DOM manipulation by making React render
        into detached DOM elements, which are added to the DOM outside of
        React's control. The React logic itself is not incremental.
        */
        function ReactIncrementalPortals() {
            /*
            Let's cheat React's rendering by using portals. Portals are a
            feature of React where you can tell it to render into an
            arbitrary DOM element. We can use this, combined with refs to give
            us access to the underlying DOM nodes, to make React render into
            a bunch of detached DOM elements, which we then incrementally
            add to the document.
            */

            const [query, setQuery] = React.useState('');

            /*
            These are all refs because we need persistent but mutable values that won't trigger updates
            when we change them.
            */
            const container = React.useRef(null);
            const renderHandle = React.useRef(null);
            const renderDivs = React.useRef([]);

            function handleChange(e) {
                setQuery(e.target.value);
            }

            React.useEffect(() => {
                clearTimeout(renderHandle.current);
                container.current.innerHTML = '';

                function renderIncremental(divs, i = 0) {
                    let numItems = 0;

                    if (i < results.length) {
                        while (numItems < MAX_INCREMENTAL && i < divs.length) {
                            container.current.appendChild(divs[i]);
                            numItems++;
                            i++;
                        }

                        const handle = setTimeout(() => renderIncremental(divs, i), 0);
                        renderHandle.current = handle;
                    }
                }

                renderIncremental(renderDivs.current, 0);

                // Cleanup function in case the thing unmounts
                return () => {
                    clearTimeout(renderHandle.current);
                }
            }, [query]);

            const [results, summary] = runSearch(query);
            const divs = new Array(results.length);
            const portals = new Array(results.length);
            for (let i = 0; i < results.length; i++) {
                const r = results[i];

                const div = document.createElement('div');
                divs[i] = div;
                portals[i] = ReactDOM.createPortal(
                    e(SearchResult, {result: r}),
                    div,
                );
            }

            renderDivs.current = divs;

            return e(React.Fragment, {},
                e('input', {value: query, onChange: handleChange}),
                e('div', {ref: container}, portals),
            );
        }
        ReactDOM.render(e(ReactIncrementalPortals), document.querySelector('#rip-container'));
    </script>
</body>

</html>
